---
keywords: fastai
description: "Data science and machine learning relies on high quality datasets for visualization, statistical inference, and modeling. Statistical typing is a runtime typing system that enables data scientists, engineers, and analysts to validate real-world data and isolate units of processing, analysis, or model-training logic to implement more robust data testing."
title: "Statistical Typing: A Runtime Type System for Data Science and Machine Learning"
toc: false
branch: master
badges: true
comments: true
categories: [statistical typing, unit testing]
image: images/logo.png
hide: false
search_exclude: true
nb_path: _notebooks/2020-12-26-statistical-typing.ipynb
layout: notebook
---

<!--
#################################################
### THIS FILE WAS AUTOGENERATED! DO NOT EDIT! ###
#################################################
# file to edit: _notebooks/2020-12-26-statistical-typing.ipynb
-->

<div class="container" id="notebook-container">
        
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="The-Data-Quality-Problem">The Data Quality Problem<a class="anchor-link" href="#The-Data-Quality-Problem"> </a></h1><p>One of the central challenges in data science (DS) and machine learning (ML) is
managing and maintaining data quality. As an ML engineer and  practitioner who
frequently constructs, cleans, explores, and models proprietary (i.e. non-benchmark)
datasets, "bad data" makes all the difference between accurate versus misleading
data visualizations, statistical inferences, and models. In this article I want
to hone in on three problems that are fairly unique to DS/ML practice when it comes to
dealing with tabular data in the Python ecosystem using <a href="https://pandas.pydata.org/https://pandas.pydata.org/">pandas</a>,
which is one of the de facto tools for data manipulation in the DS/ML toolchain.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Data-Integrity-Errors-Fail-Silently">Data Integrity Errors Fail Silently<a class="anchor-link" href="#Data-Integrity-Errors-Fail-Silently"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Tooling for type safety is improving in the Python with the broad adoption
of the <a href="https://docs.python.org/3/library/typing.html">typing</a> module and
projects like <a href="http://mypy-lang.org/">mypy</a>, which eases the developer
experience for writing readable, reliable code.</p>
<p>However, for most DS/ML work, this isn't quite sufficient. This is because
logical data types don't always capture the statistical distributions of the
variables under study, which is a key thing to do when, for example, your data
distribution shifts as a result of a world-wide pandemic,
<a href="https://www.technologyreview.com/2020/05/11/1001563/covid-pandemic-broken-ai-machine-learning-amazon-retail-fraud-humans-in-the-loop/">causing ML models to break</a>
in unexpected ways.</p>
<p>Having systems in place that fail early (and loudly üîä) when the data distribution
is not what you assumed is one of the critical pieces to building reliable
production systems, and we need better tooling for this.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Testing-Software-is-Hard">Testing Software is Hard<a class="anchor-link" href="#Testing-Software-is-Hard"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Another important tool in the developer's arsenal is testing. There are many
<a href="https://www.amazon.com/dp/1617296279">books</a>, <a href="https://kentcdodds.com/blog/write-tests">articles</a>, and
<a href="https://stackoverflow.com/questions/5357601/whats-the-difference-between-unit-tests-and-integration-tests">discussions</a>
available online about different types of testing techniques and how to put them
into practice. I won't dive deeply into it here, but in short, testing your code
makes it easier to change it and know when you've broken something and doubly serves as
documentation.</p>
<p>Even in exploratory or research contexts, it's a good idea to write tests for your
code because it strengthens your confidence in the robustness of the insights that
you're taking away from your analysis.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Testing-Software-and-Statistical-Distributions-is-Even-Harder">Testing Software and Statistical Distributions is Even Harder<a class="anchor-link" href="#Testing-Software-and-Statistical-Distributions-is-Even-Harder"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>The challenge with testing software compounds when processing data for the
purpose of statistical analysis and modeling.</p>
<p>Consider a machine learning pipeline that creates a predictive model from
survey responses. The barriers to the testing data and transformation code
tends to be much higher than the business logic that processes survey responses
and stores raw values in a database because the latter tends to be simpler
and more atomic by design.</p>
<p>By <em>atomic</em> ‚öõ I mean that each piece of data that's filled out by respondents
and stored in the database can be tested in isolation without having to
analyze the aggregate statistical patterns across a larger sample of responses.
On the other hand, for my statistical analysis to make sense, the overall
integrity of the statistical distribution üìä of the responses needs to be taken
into account.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Technical-Debt:-No-Tests-==-Legacy-Code">Technical Debt: <code>No Tests == Legacy Code</code><a class="anchor-link" href="#Technical-Debt:-No-Tests-==-Legacy-Code"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Because the effort that goes into exploring, cleaning, and figuring out how to
test my dataset is so high, I'm discouraged from writing tests for my pipeline
code. As the famous software development quip goes:</p>
<blockquote><p>"legacy code is code without tests"</p>
<ul>
<li>Michael C. Feathers, <a href="https://www.amazon.com/Working-Effectively-Legacy-Robert-Martin/dp/0131177052">Working Effectively with Legacy Code</a></li>
</ul>
</blockquote>
<p>But you might think: "but when I put my code in production, surely I
‚Äì or my ML engineer collaborator ‚Äì will write tests then?". The thing is,
regardless of who writes those tests or when their written, someone'll have to
do it at some point, so the sooner and more quickly you can climb
the technical debt mountain üèî the better!</p>
<p>In the rest of this post I'll try to convince you that statistical typing gives
us the tools we need to do just that.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="What's-Statistical-Typing?">What's Statistical Typing?<a class="anchor-link" href="#What's-Statistical-Typing?"> </a></h1><p>If you've used strong, statically-typed languages before, or the <a href="http://mypy-lang.org/">mypy</a>
static type checker with type-hinting in Python, you may have noticed that type definitions can
often catch nasty type-related bugs üêû that render certain kinds of unit tests unnecessary. Other
tools, like <a href="https://pydantic-docs.helpmanual.io/">pydantic</a>, enforce types at runtime via a
data parsing model.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Beyond-Logical-Data-Types">Beyond Logical Data Types<a class="anchor-link" href="#Beyond-Logical-Data-Types"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Statistical typing extends the concept of <a href="https://en.wikipedia.org/wiki/Data_type">logical data types</a>
to the class of <a href="https://en.wikipedia.org/wiki/Statistical_data_type">statistical data types</a>
and, ultimately, <a href="https://en.wikipedia.org/wiki/List_of_probability_distributions">probability distributions</a>.
Statistical data types builds on top of logical data types, and in fact there's considerable overlap between the two.</p>
<p>For example, the <em>binary</em> logical data type is also a statistical data type. The key
difference is that statistical data types hold additional semantics that govern the kinds
of statistical operations that we can perform on variables of a particular type and
probability distributions that describe those variables.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Statistical-Distributions-as-Schemas">Statistical Distributions as Schemas<a class="anchor-link" href="#Statistical-Distributions-as-Schemas"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>What if you can specify the set of acceptable values that a variable can take,
from the data type, set/range of values, or even what distribution a particular
variable is drawn from? This is the goal of statistical typing: to enumerate a
practical set of constraints that specify what should be considered valid data for
a particular dataset.</p>
<p>For example, we might want a <em>categorical</em> variable to be drawn <em>somewhat</em> uniformly
from a set of values <code>{A, B, C}</code>. We can express this as a hypothesis test that
causes our pipeline to fail if any one of the values occurs significantly more
frequently than the others, given a pre-defined level of statistical significance.</p>
<p>Or we may want a <em>real-valued</em> variable to be drawn roughly from a normal
distribution with mean <code>¬µ</code> and variance <code>œÉ</code>, which can also be specified with an
alpha value that the we deem acceptable for a particular analysis.</p>
<p>In essence, a statistical typing implementation involves specifying three kinds
of metadata for a given set of variables:</p>
<ol>
<li>logical data types, e.g. <code>int</code>, <code>str</code>, <code>float</code>, etc.</li>
<li>deterministic properties, e.g. <code>categorical</code> values and <code>real-valued</code> ranges</li>
<li>probabilistic properties, e.g. sufficient statistics like <code>mean</code>, <code>standard deviation</code></li>
</ol>
<p>The challenge presented by item <em>3</em> is obvious: discovering the underlying
probability distributions of real-world data is often non-trivial. However,
even if we can only express or automatically infer these metadata up to point
<em>2</em>, we can get still something quite powerful üí™: <strong>property-based testing of statistical
analysis code</strong>.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Schemas-as-Generative-Data-Contracts-&#128220;">Schemas as Generative Data Contracts &#128220;<a class="anchor-link" href="#Schemas-as-Generative-Data-Contracts-&#128220;"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>With a statistically-typed schema, not only can we validate real-world data to
ensure that our assumptions about them hold up, but we can also test our data
transformation, analysis, and modeling code <em>given valid samples</em> according to
our schema definition. Statistical typing effectively gives DS/ML practitioners
the tools to easily isolate their code from real-world data, providing a convenient
way of implementing unit tests.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="Statistical-Typing-in-Practice-with-pandera">Statistical Typing in Practice with <code>pandera</code><a class="anchor-link" href="#Statistical-Typing-in-Practice-with-pandera"> </a></h1>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Let me illustrate how these concepts would work in practice with a toy problem using
<a href="https://github.com/pandera-dev/pandera">pandera</a>, a runtime data validation library
for <a href="https://pandas.pydata.org/">pandas dataframes</a> that I've been developing over
the last few years.</p>
<p>Suppose you're building a predictive model of house prices given features about
different houses:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">raw_data</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">square_footage,n_bedrooms,property_type,price</span>
<span class="s2">750,1,condo,200000</span>
<span class="s2">900,2,condo,400000</span>
<span class="s2">1200,2,house,500000</span>
<span class="s2">1100,3,house,450000</span>
<span class="s2">1000,2,condo,300000</span>
<span class="s2">1000,2,townhouse,300000</span>
<span class="s2">1200,2,townhouse,350000</span>
<span class="s2">&quot;&quot;&quot;</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the raw data above you can see that we have the following columns:</p>
<ul>
<li>feature 1: <code>square_footage</code></li>
<li>feature 2: <code>n_bedrooms</code></li>
<li>feature 3: <code>property_type</code></li>
<li>target: <code>price</code></li>
</ul>
<p>Our modeling pipeline will involve two steps:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">raw_data</span><span class="p">):</span>  <span class="c1"># step 1: prepare data for model training</span>
    <span class="o">...</span>
    
<span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">processed_data</span><span class="p">):</span> <span class="c1"># step 2: fit a model on processed data</span>
    <span class="o">...</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Defining-Schemas-with-pandera">Defining Schemas with <code>pandera</code><a class="anchor-link" href="#Defining-Schemas-with-pandera"> </a></h3>
</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>At its core, <code>pandera</code> provides a flexible and expressive API for defining
dataframe schemas and seamlessly integrating data validation logic into your
data analysis pipelines, all while separating the concerns of data cleaning
and validation.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandera</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="kn">from</span> <span class="nn">pandera.typing</span> <span class="kn">import</span> <span class="n">Series</span>


<span class="n">PROPERTY_TYPES</span> <span class="o">=</span> <span class="p">[</span><span class="s2">&quot;condo&quot;</span><span class="p">,</span> <span class="s2">&quot;townhouse&quot;</span><span class="p">,</span> <span class="s2">&quot;house&quot;</span><span class="p">]</span>


<span class="k">class</span> <span class="nc">BaseSchema</span><span class="p">(</span><span class="n">pa</span><span class="o">.</span><span class="n">SchemaModel</span><span class="p">):</span>
    <span class="n">square_footage</span><span class="p">:</span> <span class="n">Series</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">in_range</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;min_value&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">:</span> <span class="mi">3000</span><span class="p">})</span>
    <span class="n">n_bedrooms</span><span class="p">:</span> <span class="n">Series</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">in_range</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;min_value&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">:</span> <span class="mi">10</span><span class="p">})</span>
    <span class="n">price</span><span class="p">:</span> <span class="n">Series</span><span class="p">[</span><span class="nb">float</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">in_range</span><span class="o">=</span><span class="p">{</span><span class="s2">&quot;min_value&quot;</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;max_value&quot;</span><span class="p">:</span> <span class="mi">1000000</span><span class="p">})</span>

    <span class="k">class</span> <span class="nc">Config</span><span class="p">:</span>
        <span class="n">coerce</span> <span class="o">=</span> <span class="kc">True</span>


<span class="k">class</span> <span class="nc">RawData</span><span class="p">(</span><span class="n">BaseSchema</span><span class="p">):</span>
    <span class="n">property_type</span><span class="p">:</span> <span class="n">Series</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">isin</span><span class="o">=</span><span class="n">PROPERTY_TYPES</span><span class="p">)</span>


<span class="k">class</span> <span class="nc">ProcessedData</span><span class="p">(</span><span class="n">BaseSchema</span><span class="p">):</span>
    <span class="n">property_type_condo</span><span class="p">:</span> <span class="n">Series</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">isin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">property_type_house</span><span class="p">:</span> <span class="n">Series</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">isin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
    <span class="n">property_type_townhouse</span><span class="p">:</span> <span class="n">Series</span><span class="p">[</span><span class="nb">int</span><span class="p">]</span> <span class="o">=</span> <span class="n">pa</span><span class="o">.</span><span class="n">Field</span><span class="p">(</span><span class="n">isin</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">])</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>In the code above, we can see that we're defining a <code>BaseSchema</code>, which shares
columns that are common between the raw and processed data. We're also making
sure that the columns are coerced to the expected data types during validation.</p>
<p><code>RawData</code> and <code>ProcessedData</code> inherit from <code>BaseSchema</code>, and just by looking
at them we can see the difference that we expect between the raw and processed data:
our <code>process_data</code> function should convert the <code>property_type</code> categorical
variable into a set of dummy variables.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Runtime-Data-Testing">Runtime Data Testing<a class="anchor-link" href="#Runtime-Data-Testing"> </a></h3><p>Now we use python's type-hinting syntax to annotate the <code>process_data</code> and
<code>train_model</code> functions, decorating them with <code>@pa.check_types</code> to make sure
that the inputs and outputs are validated at runtime:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">pandera</span> <span class="k">as</span> <span class="nn">pa</span>
<span class="kn">from</span> <span class="nn">pandera.typing</span> <span class="kn">import</span> <span class="n">DataFrame</span>
<span class="kn">from</span> <span class="nn">sklearn.linear_model</span> <span class="kn">import</span> <span class="n">LinearRegression</span>


<span class="nd">@pa</span><span class="o">.</span><span class="n">check_types</span>
<span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">raw_data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">[</span><span class="n">RawData</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">[</span><span class="n">ProcessedData</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">get_dummies</span><span class="p">(</span>
        <span class="n">raw_data</span><span class="o">.</span><span class="n">astype</span><span class="p">({</span><span class="s2">&quot;property_type&quot;</span><span class="p">:</span> <span class="n">pd</span><span class="o">.</span><span class="n">CategoricalDtype</span><span class="p">(</span><span class="n">PROPERTY_TYPES</span><span class="p">)})</span>
    <span class="p">)</span>

<span class="nd">@pa</span><span class="o">.</span><span class="n">check_types</span>
<span class="k">def</span> <span class="nf">train_model</span><span class="p">(</span><span class="n">processed_data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">[</span><span class="n">ProcessedData</span><span class="p">]):</span>
    <span class="n">estimator</span> <span class="o">=</span> <span class="n">LinearRegression</span><span class="p">()</span>
    <span class="n">targets</span> <span class="o">=</span> <span class="n">processed_data</span><span class="p">[</span><span class="s2">&quot;price&quot;</span><span class="p">]</span>
    <span class="n">features</span> <span class="o">=</span> <span class="n">processed_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">estimator</span><span class="o">.</span><span class="n">fit</span><span class="p">(</span><span class="n">features</span><span class="p">,</span> <span class="n">targets</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">estimator</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Now every time we run our pipeline our data is validated as it passes through
the various transformations:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">from</span> <span class="nn">io</span> <span class="kn">import</span> <span class="n">StringIO</span>


<span class="k">def</span> <span class="nf">run_pipeline</span><span class="p">(</span><span class="n">raw_data</span><span class="p">):</span>
    <span class="n">processed_data</span> <span class="o">=</span> <span class="n">process_data</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>
    <span class="n">estimator</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">processed_data</span><span class="p">)</span>
    <span class="c1"># evaluate model, save artifacts, etc...</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;model training successful!&quot;</span><span class="p">)</span>


<span class="n">run_pipeline</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">raw_data</span><span class="o">.</span><span class="n">strip</span><span class="p">())))</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>model training successful!
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>So if we pass invalid data into <code>run_pipeline</code>, we should get an error:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">invalid_data</span> <span class="o">=</span> <span class="s2">&quot;&quot;&quot;</span>
<span class="s2">square_footage,n_bedrooms,property_type,price</span>
<span class="s2">750,1,unknown,200000</span>
<span class="s2">900,2,condo,400000</span>
<span class="s2">1200,2,house,500000</span>
<span class="s2">&quot;&quot;&quot;</span>

<span class="k">try</span><span class="p">:</span>
    <span class="n">run_pipeline</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">read_csv</span><span class="p">(</span><span class="n">StringIO</span><span class="p">(</span><span class="n">invalid_data</span><span class="o">.</span><span class="n">strip</span><span class="p">())))</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>error in check_types decorator of function &#39;process_data&#39;: &lt;Schema Column: &#39;property_type&#39; type=&lt;class &#39;str&#39;&gt;&gt; failed element-wise validator 0:
&lt;Check isin: isin({&#39;house&#39;, &#39;condo&#39;, &#39;townhouse&#39;})&gt;
failure cases:
   index failure_case
0      0      unknown
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, <code>pandera</code> tells exactly what went wrong: the <code>property_type</code>
column has an invalid category <code>unknown</code> at the 0th entry.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h3 id="Property-based-Testing">Property-based Testing<a class="anchor-link" href="#Property-based-Testing"> </a></h3><p>But wait, there's more! Since we've already defined our schemas, we can isolate
the processing and model-training code from real-world data to test that
each component in your pipeline is functioning as expected.</p>
<p><code>pandera</code> builds on top of the <a href="https://hypothesis.readthedocs.io/">hypothesis</a>
package to generate synthetic data from search strategies that try to find
the simplest case that would falsify your tests:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="kn">import</span> <span class="nn">hypothesis</span>

<span class="nd">@hypothesis</span><span class="o">.</span><span class="n">given</span><span class="p">(</span><span class="n">RawData</span><span class="o">.</span><span class="n">strategy</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_process_data</span><span class="p">(</span><span class="n">raw_data</span><span class="p">):</span>
    <span class="n">process_data</span><span class="p">(</span><span class="n">raw_data</span><span class="p">)</span>

    
<span class="nd">@hypothesis</span><span class="o">.</span><span class="n">given</span><span class="p">(</span><span class="n">ProcessedData</span><span class="o">.</span><span class="n">strategy</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">test_train_model</span><span class="p">(</span><span class="n">processed_data</span><span class="p">):</span>
    <span class="n">estimator</span> <span class="o">=</span> <span class="n">train_model</span><span class="p">(</span><span class="n">processed_data</span><span class="p">)</span>
    <span class="n">preds</span> <span class="o">=</span> <span class="n">estimator</span><span class="o">.</span><span class="n">predict</span><span class="p">(</span><span class="n">processed_data</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="s2">&quot;price&quot;</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
    <span class="k">assert</span> <span class="nb">len</span><span class="p">(</span><span class="n">preds</span><span class="p">)</span> <span class="o">==</span> <span class="n">processed_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>

    </div>
</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We could run this as a <a href="https://docs.python.org/3/library/unittest.html">unittest</a>
or <a href="https://docs.pytest.org/">pytest</a> suite, but for now we can just run the
tests manually like so:</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="k">def</span> <span class="nf">run_test_suite</span><span class="p">():</span>
    <span class="n">test_process_data</span><span class="p">()</span>
    <span class="n">test_train_model</span><span class="p">()</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;‚úÖ tests successful!&quot;</span><span class="p">)</span>
    
    
<span class="n">run_test_suite</span><span class="p">()</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>‚úÖ tests successful!
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>So if we were to incorrectly implement any of the components in our pipeline,
we'd see errors early on. In this case, we're just going to return the raw data
without the dummified <code>property_type</code> variable.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="nd">@pa</span><span class="o">.</span><span class="n">check_types</span>
<span class="k">def</span> <span class="nf">process_data</span><span class="p">(</span><span class="n">raw_data</span><span class="p">:</span> <span class="n">DataFrame</span><span class="p">[</span><span class="n">RawData</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">DataFrame</span><span class="p">[</span><span class="n">ProcessedData</span><span class="p">]:</span>
    <span class="k">return</span> <span class="n">raw_data</span>


<span class="k">try</span><span class="p">:</span>
    <span class="n">run_test_suite</span><span class="p">()</span>
<span class="k">except</span> <span class="ne">Exception</span> <span class="k">as</span> <span class="n">e</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">

<div class="output_subarea output_stream output_stdout output_text">
<pre>Falsifying example: test_process_data(
    raw_data=   square_footage  n_bedrooms  price property_type
    0               0           0    0.0         condo
    1               0           0    0.0         condo
    2               0           0    0.0         condo,
)
error in check_types decorator of function &#39;process_data&#39;: column &#39;property_type_condo&#39; not in dataframe
   square_footage  n_bedrooms  price property_type
0               0           0    0.0         condo
1               0           0    0.0         condo
2               0           0    0.0         condo
</pre>
</div>
</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Here, our test suite catches the fact that <code>property_type_condo</code> doesn't exist
in our processed data output.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>We can get some more intuition about what's going on with the data synthesis
strategies by interactively generating data using the <code>example</code> method.</p>

</div>
</div>
</div>
    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">RawData</span><span class="o">.</span><span class="n">example</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>square_footage</th>
      <th>n_bedrooms</th>
      <th>price</th>
      <th>property_type</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>2042</td>
      <td>7</td>
      <td>746370.512051</td>
      <td>townhouse</td>
    </tr>
    <tr>
      <th>1</th>
      <td>9</td>
      <td>5</td>
      <td>40167.336181</td>
      <td>townhouse</td>
    </tr>
    <tr>
      <th>2</th>
      <td>467</td>
      <td>9</td>
      <td>3707.778242</td>
      <td>townhouse</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

    {% raw %}
    
<div class="cell border-box-sizing code_cell rendered">
<div class="input">

<div class="inner_cell">
    <div class="input_area">
<div class=" highlight hl-ipython3"><pre><span></span><span class="n">ProcessedData</span><span class="o">.</span><span class="n">example</span><span class="p">(</span><span class="n">size</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</pre></div>

    </div>
</div>
</div>

<div class="output_wrapper">
<div class="output">

<div class="output_area">


<div class="output_html rendered_html output_subarea output_execute_result">
<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>square_footage</th>
      <th>n_bedrooms</th>
      <th>price</th>
      <th>property_type_condo</th>
      <th>property_type_house</th>
      <th>property_type_townhouse</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1625</td>
      <td>8</td>
      <td>417650.777844</td>
      <td>0</td>
      <td>0</td>
      <td>0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>317</td>
      <td>0</td>
      <td>788150.855590</td>
      <td>1</td>
      <td>1</td>
      <td>1</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1937</td>
      <td>7</td>
      <td>710676.511681</td>
      <td>1</td>
      <td>0</td>
      <td>1</td>
    </tr>
  </tbody>
</table>
</div>
</div>

</div>

</div>
</div>

</div>
    {% endraw %}

<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<p>Under the hood, <code>pandera</code> is collecting all of the schema properties and
converting it into a search strategy using the
<a href="https://hypothesis.readthedocs.io/en/latest/numpy.html#pandas">pandas-supported hypothesis strategies</a>.
Currently, one limitation that you can see from the <code>ProcessedData</code> example above is that the
generated data doesn't quite capture the joint distribution between the <code>property_type_*</code> dummy
variables, as the second row contains <code>1</code>s for all of the property types. Depending on
what exactly it is you're trying to test, this may or may not matter. Ultimately, it's
still up to you to determine what to test and how.</p>

</div>
</div>
</div>
<div class="cell border-box-sizing text_cell rendered"><div class="inner_cell">
<div class="text_cell_render border-box-sizing rendered_html">
<h1 id="What's-Next?">What's Next?<a class="anchor-link" href="#What's-Next?"> </a></h1><p>There's still a lot to do in <code>pandera</code> to fully-realize the vision of
statistical typing, but I think the main API ideas and features are there
to get started and reap the benefits of statistical typing:</p>
<ol>
<li>Runtime data validation when executing pipeline during development/production.</li>
<li>Property-based unit testing by isolating transformation code from real data.</li>
<li>Self-documenting pipelines that explicitly define the types and statistical
properties of data as it flows through your pipeline.</li>
</ol>
<p>There are a few things in the roadmap that I'm excited about:</p>
<ul>
<li><a href="https://github.com/pandera-dev/pandera/issues/369">Decouple <code>pandera</code> and <code>pandas</code> type systems</a></li>
<li><a href="https://github.com/pandera-dev/pandera/issues/119">Add support for parallelized dataframes for larger datasets</a></li>
<li><a href="https://github.com/pandera-dev/pandera/issues/168">Add a more comprehensive suite of built-in statistical hypothesis tests</a></li>
<li><a href="https://github.com/pandera-dev/pandera/issues/370">Implement data synthesis strategies for hypothesis tests</a></li>
<li><a href="https://github.com/pandera-dev/pandera/issues/371">Support data synthesis strategies for joint distributions</a></li>
<li><a href="https://github.com/pandera-dev/pandera/issues/179">Support machine learning workflows with machine learning schemas</a></li>
</ul>
<p>If you're interested in this project, please consider helping out with
<a href="https://github.com/pandera-dev/pandera/blob/master/.github/CONTRIBUTING.md">code contributions</a>,
<a href="https://github.com/pandera-dev/pandera/issues">submitting feature requests, bugs, documentation improvements</a>,
and <a href="https://github.com/sponsors/cosmicBboy">support</a>!</p>

</div>
</div>
</div>
</div>
 

